API
Goed rekening gehouden met exceptions die vanuit lagerliggende lagen gegooid kunnen worden. Deze wil je altijd 'verpakken' naar iets dat je kan teruggeven aan de consumers/clients van jouw API. Dit doe je goed (e.g. BadRequest). Je kan wel eventueel kritisch kijken naar wanneer je een 4xx statuscode teruggeeft (e.g. een BadRequest) versus een 5xx internal server error. Een statuscode startend met een 4 wilt zeggen dat de 'schuld' bij de client ligt en hij in principe zijn call moet corrigeren om dan opnieuw te proberen. Een statuscode startend met een 5 wijst op een internal server error. De schuld ligt bij de server. Er is op zich weinig wat de client hier aan kan doen (hij weet dus dat hij niet opnieuw moet proberen).
I.v.m. Exception handling. Kijk eens aan de 'Middelware' oplossing die Kenny had voorgesteld: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x&view=aspnetcore-2.1#ordering & http://netitude.bc3tech.net/2017/07/31/using-middleware-to-trap-exceptions-in-asp-net-core/
User versus Customer is mij heel erg verwarrend... de CustomerController gebruikt een UserDtoToCreate object... Tegelijkertijd is er een UserController?
De resources m.b.t. REST dienen volgens de conventie altijd meervoud te zijn. Dus api/items i.p.v. api/item.
Goeie functionele namespaces en onderverdeling.
Domain
In je Domain had je nog bepaalde Repository classes kunnen aanmaken. Deze konden dan op hun beurt communiceren met de onderliggende Databases (die nu heel dummy in-memory objecten zijn). Je tussenliggende services hadden dan dependencies op de repositories. De repositories op de databases. Dit dan in plaats van dat je services nu static dependencies hebben op de databases. We zouden indirectie toepassen.
Er zit een grote design fout in jouw code bij het aanmaken van een order. De ItemDtoToOrder bevat een Name en een OrderAmount. Je gebruikt nadien de name om het effectieve Item op te gaan halen. Dus m.a.w. je gebruikt de Name als een ID. Niets garandeert uniekheid op basis van Name. Dit is dus een recipe for disaster. Je kopieert daarnaast ook de description (en name) over van een Item naar een ItemGroup. Dit is niet nodig. De prijs moet je wel over kopiëren. Indien onzeker waarom name en description niet, maar prijs wel: ask!
Een Item heeft velden ToOrder en OnOrder ??? Dus een Item weet tot welk Order hij behoort? Wat als een Item gekocht is via meerdere orders? Dit zit niet goed in elkaar.
Integration tests
Goed tijd gestoken in de integratie testen. Ze zien er ook best goed uit. Je zou bijvoorbeeld nog iets grondiger kunnen gaan in bepaalde controller end-to-end testen: e.g.: test CreateNewItem_WhenAdminUserAddNonExistingItem_ThenReturnSuccess() van de ItemControllerIntegrationTest. Hierin had je eventueel kunnen asserten dat de ItemDtoToCreate dto die je terugkrijgt als antwoord uit de call bepaalde waardes (zoals een name en ID) bevat.
Het probleem van parallellisatie waardoor jouw testen faalden wanneer je ze tegelijkertijd draait is er eentje dat we hebben omdat we met een in-memory mechanisme werken voor de database. Van zodra we met EF werken (en we dus transacties hebben die kunnen rollbacken na elke test), zou je niet meer tegen dit probleem mogen aanlopen.
Spellingsfoutjes
Probeer er wat meer op te letten... :D